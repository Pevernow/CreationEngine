// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NETWORK_NETWORK_H_
#define FLATBUFFERS_GENERATED_NETWORK_NETWORK_H_

#include "flatbuffers/flatbuffers.h"

namespace Network {

struct NodeDefinition;

struct ItemDefinition;

struct Message;

enum Type {
  Type_RegisterNodeList = 0,
  Type_RegisterItemList = 1,
  Type_MIN = Type_RegisterNodeList,
  Type_MAX = Type_RegisterItemList
};

inline const Type (&EnumValuesType())[2] {
  static const Type values[] = {
    Type_RegisterNodeList,
    Type_RegisterItemList
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[] = {
    "RegisterNodeList",
    "RegisterItemList",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_RegisterNodeList || e > Type_RegisterItemList) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

struct NodeDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FRONT = 6,
    VT_BACK = 8,
    VT_LEFT = 10,
    VT_RIGHT = 12,
    VT_TOP = 14,
    VT_BOTTOM = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *front() const {
    return GetPointer<const flatbuffers::String *>(VT_FRONT);
  }
  const flatbuffers::String *back() const {
    return GetPointer<const flatbuffers::String *>(VT_BACK);
  }
  const flatbuffers::String *left() const {
    return GetPointer<const flatbuffers::String *>(VT_LEFT);
  }
  const flatbuffers::String *right() const {
    return GetPointer<const flatbuffers::String *>(VT_RIGHT);
  }
  const flatbuffers::String *top() const {
    return GetPointer<const flatbuffers::String *>(VT_TOP);
  }
  const flatbuffers::String *bottom() const {
    return GetPointer<const flatbuffers::String *>(VT_BOTTOM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FRONT) &&
           verifier.VerifyString(front()) &&
           VerifyOffset(verifier, VT_BACK) &&
           verifier.VerifyString(back()) &&
           VerifyOffset(verifier, VT_LEFT) &&
           verifier.VerifyString(left()) &&
           VerifyOffset(verifier, VT_RIGHT) &&
           verifier.VerifyString(right()) &&
           VerifyOffset(verifier, VT_TOP) &&
           verifier.VerifyString(top()) &&
           VerifyOffset(verifier, VT_BOTTOM) &&
           verifier.VerifyString(bottom()) &&
           verifier.EndTable();
  }
};

struct NodeDefinitionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(NodeDefinition::VT_NAME, name);
  }
  void add_front(flatbuffers::Offset<flatbuffers::String> front) {
    fbb_.AddOffset(NodeDefinition::VT_FRONT, front);
  }
  void add_back(flatbuffers::Offset<flatbuffers::String> back) {
    fbb_.AddOffset(NodeDefinition::VT_BACK, back);
  }
  void add_left(flatbuffers::Offset<flatbuffers::String> left) {
    fbb_.AddOffset(NodeDefinition::VT_LEFT, left);
  }
  void add_right(flatbuffers::Offset<flatbuffers::String> right) {
    fbb_.AddOffset(NodeDefinition::VT_RIGHT, right);
  }
  void add_top(flatbuffers::Offset<flatbuffers::String> top) {
    fbb_.AddOffset(NodeDefinition::VT_TOP, top);
  }
  void add_bottom(flatbuffers::Offset<flatbuffers::String> bottom) {
    fbb_.AddOffset(NodeDefinition::VT_BOTTOM, bottom);
  }
  explicit NodeDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeDefinitionBuilder &operator=(const NodeDefinitionBuilder &);
  flatbuffers::Offset<NodeDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeDefinition>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeDefinition> CreateNodeDefinition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> front = 0,
    flatbuffers::Offset<flatbuffers::String> back = 0,
    flatbuffers::Offset<flatbuffers::String> left = 0,
    flatbuffers::Offset<flatbuffers::String> right = 0,
    flatbuffers::Offset<flatbuffers::String> top = 0,
    flatbuffers::Offset<flatbuffers::String> bottom = 0) {
  NodeDefinitionBuilder builder_(_fbb);
  builder_.add_bottom(bottom);
  builder_.add_top(top);
  builder_.add_right(right);
  builder_.add_left(left);
  builder_.add_back(back);
  builder_.add_front(front);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeDefinition> CreateNodeDefinitionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *front = nullptr,
    const char *back = nullptr,
    const char *left = nullptr,
    const char *right = nullptr,
    const char *top = nullptr,
    const char *bottom = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto front__ = front ? _fbb.CreateString(front) : 0;
  auto back__ = back ? _fbb.CreateString(back) : 0;
  auto left__ = left ? _fbb.CreateString(left) : 0;
  auto right__ = right ? _fbb.CreateString(right) : 0;
  auto top__ = top ? _fbb.CreateString(top) : 0;
  auto bottom__ = bottom ? _fbb.CreateString(bottom) : 0;
  return Network::CreateNodeDefinition(
      _fbb,
      name__,
      front__,
      back__,
      left__,
      right__,
      top__,
      bottom__);
}

struct ItemDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TEXTURE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *texture() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXTURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TEXTURE) &&
           verifier.VerifyString(texture()) &&
           verifier.EndTable();
  }
};

struct ItemDefinitionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ItemDefinition::VT_NAME, name);
  }
  void add_texture(flatbuffers::Offset<flatbuffers::String> texture) {
    fbb_.AddOffset(ItemDefinition::VT_TEXTURE, texture);
  }
  explicit ItemDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ItemDefinitionBuilder &operator=(const ItemDefinitionBuilder &);
  flatbuffers::Offset<ItemDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemDefinition>(end);
    return o;
  }
};

inline flatbuffers::Offset<ItemDefinition> CreateItemDefinition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> texture = 0) {
  ItemDefinitionBuilder builder_(_fbb);
  builder_.add_texture(texture);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ItemDefinition> CreateItemDefinitionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *texture = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto texture__ = texture ? _fbb.CreateString(texture) : 0;
  return Network::CreateItemDefinition(
      _fbb,
      name__,
      texture__);
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_REGISTERNODES = 6,
    VT_REGISTERITEMS = 8
  };
  Type type() const {
    return static_cast<Type>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<NodeDefinition>> *registerNodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeDefinition>> *>(VT_REGISTERNODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ItemDefinition>> *registerItems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ItemDefinition>> *>(VT_REGISTERITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_REGISTERNODES) &&
           verifier.VerifyVector(registerNodes()) &&
           verifier.VerifyVectorOfTables(registerNodes()) &&
           VerifyOffset(verifier, VT_REGISTERITEMS) &&
           verifier.VerifyVector(registerItems()) &&
           verifier.VerifyVectorOfTables(registerItems()) &&
           verifier.EndTable();
  }
};

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(Type type) {
    fbb_.AddElement<int8_t>(Message::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_registerNodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeDefinition>>> registerNodes) {
    fbb_.AddOffset(Message::VT_REGISTERNODES, registerNodes);
  }
  void add_registerItems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemDefinition>>> registerItems) {
    fbb_.AddOffset(Message::VT_REGISTERITEMS, registerItems);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type type = Type_RegisterNodeList,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeDefinition>>> registerNodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemDefinition>>> registerItems = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_registerItems(registerItems);
  builder_.add_registerNodes(registerNodes);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type type = Type_RegisterNodeList,
    const std::vector<flatbuffers::Offset<NodeDefinition>> *registerNodes = nullptr,
    const std::vector<flatbuffers::Offset<ItemDefinition>> *registerItems = nullptr) {
  auto registerNodes__ = registerNodes ? _fbb.CreateVector<flatbuffers::Offset<NodeDefinition>>(*registerNodes) : 0;
  auto registerItems__ = registerItems ? _fbb.CreateVector<flatbuffers::Offset<ItemDefinition>>(*registerItems) : 0;
  return Network::CreateMessage(
      _fbb,
      type,
      registerNodes__,
      registerItems__);
}

}  // namespace Network

#endif  // FLATBUFFERS_GENERATED_NETWORK_NETWORK_H_
